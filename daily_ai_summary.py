#!/usr/bin/env python3
"""Generate daily analysis with OpenAI using ESPN data.

Reads OpenAI and Pushover credentials from ``config.toml``.  Environment
variables ``OPENAI_API_KEY`` and ``OPENAI_MODEL`` are used as fallbacks.
"""
import subprocess
import os
from pathlib import Path
from datetime import datetime
from openai import OpenAI
import requests
from bot_daily_analysis import load_config


def run_bot_analysis() -> None:
    """Run the existing script to refresh league data.

    ``bot_daily_analysis.py`` writes fresh CSV files by default.  The
    ``--write-analysis`` and ``--write-xlsx`` flags are intentionally omitted
    because this script only needs the standard data exports.
    """
    subprocess.run(["python", "bot_daily_analysis.py"], check=True)


def collect_files(out_dir: Path) -> list[Path]:
    """Return text files generated by ``bot_daily_analysis.py``.

    XLSX files are ignored because they are binary.
    """
    files = []
    files.extend(sorted(out_dir.glob("*.csv")))
    files.extend(sorted(out_dir.glob("*.md")))
    return [f for f in files if f.suffix != ".xlsx"]


def build_user_content(files: list[Path]) -> str:
    """Concatenate file contents with headings for the prompt."""
    parts: list[str] = []
    for f in files:
        try:
            text = f.read_text(encoding="utf-8")
        except UnicodeDecodeError:
            continue
        parts.append(f"### {f.name}\n{text}")
    return "\n\n".join(parts)


def call_openai(cfg, prompt: str, user_content: str) -> str:
    """Send the prompt and user content to the OpenAI API."""
    api_key = cfg.openai_api_key or os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise RuntimeError("Provide an OpenAI API key in config or environment.")
    model = cfg.openai_model or os.getenv("OPENAI_MODEL", "gpt-4o-mini")
    client = OpenAI(api_key=api_key)
    response = client.chat.completions.create(
        model=model,
        messages=[
            {"role": "system", "content": prompt},
            {"role": "user", "content": user_content},
        ],
    )
    return response.choices[0].message.content


def send_pushover(cfg, message: str) -> None:
    """Send a Pushover notification if credentials are configured."""
    token = cfg.pushover_api_token
    user = cfg.pushover_user_key
    if not token or not user:
        return
    try:
        requests.post(
            "https://api.pushover.net/1/messages.json",
            data={
                "token": token,
                "user": user,
                "title": "Daily AI Summary",
                "message": message[:1024],
            },
            timeout=10,
        ).raise_for_status()
    except Exception as exc:  # pragma: no cover - notification failures shouldn't crash
        print(f"Failed to send Pushover notification: {exc}")


def main() -> None:
    run_bot_analysis()
    cfg = load_config()
    out_dir = Path(cfg.out_dir)

    prompt = Path("ai_prompt.txt").read_text(encoding="utf-8")
    files = collect_files(out_dir)
    user_content = build_user_content(files)
    ai_reply = call_openai(cfg, prompt, user_content)

    out_file = out_dir / f"ai_recommendations_{datetime.now().strftime('%Y-%m-%d')}.md"
    out_file.write_text(ai_reply, encoding="utf-8")
    print(f"Wrote AI recommendations to {out_file}")

    send_pushover(cfg, ai_reply)


if __name__ == "__main__":
    main()
